package ru.eustas.mist4j;

import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.Label;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import static ru.eustas.mist4j.TemplateAsmConst.Utils.l;
import static ru.eustas.mist4j.TemplateAsmConst.Utils.pushInt;

import ru.eustas.mist4j.TemplateData.Range;

/**
 * Byte-code generator.
 * 
 * @author Klyuchnikow Eugene
 * @version 2008.10.20 - initial version
 */
public class TemplateAsm extends TemplateAsmConst implements Opcodes {

	/**
	 * Generating method.
	 * 
	 * <p>
	 * For more details see <a
	 * href="http://code.google.com/p/mist4j/wiki/ASM">mist4j opcodes</a>
	 * </p>
	 * 
	 * @param genCls internal name for class to be generated
	 * @param victimCls internal name for victim class
	 * @param ranges literal data descriptors
	 * @param invokers substitute method names
	 * @return generated byte-code
	 */
	public static byte[] dump(String genCls, String victimCls, Range[] ranges,
			String[] invokers) {

		ClassWriter cw = new ClassWriter(0);
		FieldVisitor fv;
		MethodVisitor mv;

		// HEADER
		cw.visit(V1_6, ACC_PUBLIC + ACC_SUPER, genCls, null, OBJECT,
				new String[] { ITEMPLATE });
		cw.visitSource(genCls, null);

		// FIELDS
		// literal variable
		fv = cw.visitField(ACC_PRIVATE + ACC_FINAL, FIELD_LITERAL, CHAR_ARRAY,
				null, null);
		fv.visitEnd();

		// CONSTRUCTORS
		// constructor header
		mv = cw.visitMethod(ACC_PUBLIC, INIT, INIT_WITH_CHARS, null, null);
		mv.visitCode();
		Label labelStart = new Label();
		mv.visitLabel(labelStart);
		// | call Object.super
		mv.visitVarInsn(ALOAD, THIS_REF);
		mv.visitMethodInsn(INVOKESPECIAL, OBJECT, INIT, VOID_METHOD);
		// | literal := src
		mv.visitVarInsn(ALOAD, THIS_REF);
		mv.visitVarInsn(ALOAD, PARAM_SRC);
		mv.visitFieldInsn(PUTFIELD, genCls, FIELD_LITERAL, CHAR_ARRAY);
		// | return
		mv.visitInsn(RETURN);
		// constructor-meta
		Label labelEnd = new Label();
		mv.visitLabel(labelEnd);
		mv.visitLocalVariable(THIS, l(genCls), null, labelStart, labelEnd,
				THIS_REF);
		mv.visitLocalVariable("src", CHAR_ARRAY, null, labelStart, labelEnd,
				PARAM_SRC);
		mv.visitMaxs(2, 2);
		mv.visitEnd();

		// METHOD
		// header
		mv = cw.visitMethod(ACC_PUBLIC + ACC_FINAL, "process", "("
				+ l(IFASTRENDERER) + ")V", null, new String[] { IOEXCEPTION });
		mv.visitCode();
		labelStart = new Label();
		mv.visitLabel(labelStart);

		// get plain victim
		mv.visitVarInsn(ALOAD, PARAM_VICTIM);

		Label labelVicFree = new Label();
		mv.visitLabel(labelVicFree);

		// plain victim now free
		mv.visitTypeInsn(CHECKCAST, victimCls);
		// duplicate cast result
		mv.visitInsn(DUP);
		// one to save
		mv.visitVarInsn(ASTORE, LOCAL_VICTIM);
		// other is used to get writer
		// | call _vic.getOut
		mv.visitMethodInsn(INVOKEVIRTUAL, victimCls, GET_OUT,
				RETURN_WRITER_METHOD);
		// save writer
		// | _out := call _vic.getOut result
		mv.visitVarInsn(ASTORE, LOCAL_OUT);
		// get this
		mv.visitVarInsn(ALOAD, THIS_REF);

		Label labelThisFree = new Label();
		mv.visitLabel(labelThisFree);

		// this now free
		// | this.literal
		mv.visitFieldInsn(GETFIELD, genCls, FIELD_LITERAL, CHAR_ARRAY);
		// | _lit=this.literal
		mv.visitVarInsn(ASTORE, LOCAL_CHARS);

		// main cycle
		int l = ranges.length;
		for (int i = 0; i < l - 1; i++) {
			pushLiteral(mv, ranges[i]);
			mv.visitVarInsn(ALOAD, LOCAL_VICTIM);
			mv.visitMethodInsn(INVOKEVIRTUAL, victimCls, invokers[i],
					VOID_METHOD);
		}
		pushLiteral(mv, ranges[l - 1]);

		// | return
		mv.visitInsn(RETURN);
		// method-meta
		labelEnd = new Label();
		mv.visitLabel(labelEnd);
		// 0
		mv.visitLocalVariable(THIS, l(genCls), null, labelStart, labelThisFree,
				THIS_REF);
		mv.visitLocalVariable("_lit", CHAR_ARRAY, null, labelThisFree,
				labelEnd, LOCAL_CHARS);
		// 1
		mv.visitLocalVariable("vic", l(OBJECT), null, labelStart, labelVicFree,
				PARAM_VICTIM);
		mv.visitLocalVariable("_vic", l(victimCls), null, labelVicFree,
				labelEnd, LOCAL_VICTIM);
		// 2
		mv.visitLocalVariable("_out", l(WRITER), null, labelVicFree, labelEnd,
				LOCAL_OUT);
		mv.visitMaxs(4, 3);
		mv.visitEnd();
		cw.visitEnd();

		return cw.toByteArray();
	}

	/**
	 * Write byte-codes for sending some literal text to output.
	 * 
	 * @param mv
	 * @param range
	 *            literal data descriptor to output
	 */
	private static void pushLiteral(MethodVisitor mv, Range range) {
		int len = range.len;
		if (len == 0) {
			return;
		}
		mv.visitVarInsn(ALOAD, 2);
		mv.visitVarInsn(ALOAD, 0);
		pushInt(mv, range.start);
		pushInt(mv, len);
		mv.visitMethodInsn(INVOKEVIRTUAL, WRITER, WRITE, WRITE_PARAMS);
	}
}